""" order router"""

import asyncio
from typing import Dict, List
import logging
import aiohttp
from app.cache import game_cache
from app.schema.game_schema import GameInfoUpdated, GameStatus
from fastapi import APIRouter, Depends, Query
from app.schema.order import OrderCreate, OrderResponse, OrderBase, OrderStatus, ProductBase, ProductCreate
from app.schema.base import ResponseModel, StatusCode
from app.repository.database import get_database
from app.repository import game_dao, order_dao as order_curd
from app.settings import SETTINGS

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/create-order", response_model=ResponseModel[OrderResponse], response_model_exclude_none=True, response_model_by_alias=False)
async def create_order(order: OrderCreate, db=Depends(get_database)):
    """create order """
    try:
        product = await order_curd.get_product_by_id(db, order.product_id)
        if product is None:
            logger.warning("product does not exist, product id %s", order.product_id)
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Product does not exist")
            
        paypal_order_id = await create_paypal_order(product.amount, product.currency)
        new_order = OrderBase(
            product_id=product.id,
            game_id=order.game_id,
            paypal_order_id=paypal_order_id,
            amount=product.amount,
            currency=product.currency,
            status=OrderStatus.CREATED,
        )
        result = await order_curd.create_order(db, new_order)
        if result is None:
            return ResponseModel(code=StatusCode.ERROR, msg="Create order failure")
        return ResponseModel(code=StatusCode.SUCCESS, data=OrderResponse(**result.model_dump()))

    except Exception as e:
        logger.error("Error creating order: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="Exception occurred while creating order")

@router.post("/capture-payment/{order_id}", response_model=ResponseModel[OrderResponse], response_model_exclude_none=True, response_model_by_alias=False)
async def capture_payment(order_id: str, db=Depends(get_database)):
    """capture payment """

    try:
        order = await order_curd.get_order_by_id(db, order_id)
        if not order:
            logger.warning("Order does not exist, order id: %s", order_id)
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Order does not exist")
        
        status_result = await check_paypal_order_status(order.paypal_order_id)
        if status_result["order_status"] != "COMPLETED":
            logger.warning("Order does not checkout, order ID：%s", order.paypal_order_id)
            return ResponseModel(code=StatusCode.ERROR, msg="Order does not checkout")
        
        await game_cache.update_game_status(order.game_id, GameStatus.PAID)
        asyncio.create_task(game_dao.update_game_status(db, order.game_id, GameStatus.PAID))

        update_order = await order_curd.update_order_status(db, order_id, OrderStatus.COMPLETED.value)
        if not update_order:
            logger.warning("Failed to update order status for order ID: %s", order_id)
            return ResponseModel(code=StatusCode.ERROR, msg="Failed to update order status")        

        return ResponseModel(code=StatusCode.SUCCESS, data=OrderResponse(**update_order.model_dump()))
    except Exception as e:
        logger.error("Error occurred while capture payment: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="Error occurred while capture payment")

@router.get("/orders", response_model=ResponseModel[List[OrderResponse]], response_model_exclude_none=True, response_model_by_alias=False)
async def get_orders(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db=Depends(get_database)
):
    """get orders"""    
    try:
        orders = await order_curd.get_orders(db, skip=skip, limit=limit)
        return ResponseModel(
            code=StatusCode.SUCCESS,
            data=[OrderResponse(**order.model_dump()) for order in orders]
        )
    except Exception as e:
        logger.error("Error occurred while fetching orders: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while fetching orders")

@router.get("/order/{order_id}", response_model=ResponseModel[OrderResponse], response_model_exclude_none=True, response_model_by_alias=False)
async def get_order(order_id: str, db=Depends(get_database)):
    """get order"""
    try:
        order = await order_curd.get_order_by_id(db, order_id)
        if not order:
            logger.warning("Order not found, order id: %s", order_id)
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Order not found")
        
        return ResponseModel(code=StatusCode.SUCCESS, data=OrderResponse(**order.model_dump()))
    except Exception as e:
        logger.error("Error occurred while fetching order: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while fetching order")

@router.post("/products", response_model=ResponseModel[ProductBase], response_model_exclude_none=True, response_model_by_alias=False)
async def create_product(product: ProductCreate, db=Depends(get_database)):
    """Create a new product"""
    try:
        product = await order_curd.create_product(db, product)
        if product is None:
            return ResponseModel(code=StatusCode.ERROR, msg="Failed to create product")
        return ResponseModel(code=StatusCode.SUCCESS, data=product)
    except Exception as e:
        logger.error("Error creating product: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while creating product")

@router.get("/products", response_model=ResponseModel[List[ProductBase]], response_model_exclude_none=True, response_model_by_alias=False)
async def get_products(
    skip: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
    db=Depends(get_database)
):
    """Get a list of products"""
    try:
        products = await order_curd.get_products(db, skip=skip, limit=limit)
        return ResponseModel(
            code=StatusCode.SUCCESS,
            data=products
        )
    except Exception as e:
        logger.error("Error fetching products: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while fetching products")

@router.get("/products/{product_id}", response_model=ResponseModel[ProductBase], response_model_exclude_none=True, response_model_by_alias=False)
async def get_product(product_id: str, db=Depends(get_database)):
    """Get a specific product by ID"""
    try:
        product = await order_curd.get_product_by_id(db, product_id)
        if not product:
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Product not found")
        return ResponseModel(code=StatusCode.SUCCESS, data=product)
    except Exception as e:
        logger.error("Error fetching product: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while fetching product")

@router.put("/products/{product_id}", response_model=ResponseModel[ProductBase], response_model_exclude_none=True, response_model_by_alias=False)
async def update_product(product_id: str, product_update: ProductCreate, db=Depends(get_database)):
    """Update an existing product"""
    try:
        updated_product = await order_curd.update_product(db, product_id, product_update)
        if not updated_product:
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Product not found")
        return ResponseModel(code=StatusCode.SUCCESS, data=updated_product)
    except Exception as e:
        logger.error("Error updating product: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while updating product")

@router.delete("/products/{product_id}", response_model=ResponseModel, response_model_exclude_none=True, response_model_by_alias=False)
async def delete_product(product_id: str, db=Depends(get_database)):
    """Delete a product"""
    try:
        deleted = await order_curd.delete_product(db, product_id)
        if not deleted:
            return ResponseModel(code=StatusCode.NOT_FOUND, msg="Product not found")
        return ResponseModel(code=StatusCode.SUCCESS, msg="Product successfully deleted")
    except Exception as e:
        logger.error("Error deleting product: %s", e)
        return ResponseModel(code=StatusCode.ERROR, msg="An exception occurred while deleting product")
    
async def create_paypal_order(amount: float, currency: str) -> str:
    """create paypal order"""

    auth_url = f"{SETTINGS.PAYPAL_API_URL}/v1/oauth2/token"
    order_url = f"{SETTINGS.PAYPAL_API_URL}/v2/checkout/orders"

    async with aiohttp.ClientSession() as session:
        auth_response = await session.post(
            auth_url,
            auth=aiohttp.BasicAuth(SETTINGS.PAYPAL_CLIENT_ID, SETTINGS.PAYPAL_CLIENT_SECRET.get_secret_value()),
            data={"grant_type": "client_credentials"}
        )
        auth_data = await auth_response.json()
        access_token = auth_data["access_token"]

        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}"
        }
        order_data = {
            "intent": "CAPTURE",
            "purchase_units": [
                {
                    "amount": {
                        "currency_code": currency,
                        "value": str(amount)
                    }
                }
            ]
        }
        order_response = await session.post(order_url, headers=headers, json=order_data)
        order_details = await order_response.json()
        logger.info("order detail %s", order_details)

        return order_details['id']

async def capture_paypal_payment(order_id: str) -> Dict:
    """捕获支付"""

    auth_url = f"{SETTINGS.PAYPAL_API_URL}/v1/oauth2/token"
    capture_url = f"{SETTINGS.PAYPAL_API_URL}/v2/checkout/orders/{order_id}/capture"

    async with aiohttp.ClientSession() as session:
        try:
            # 获取访问令牌
            auth_response = await session.post(
                auth_url,
                auth=aiohttp.BasicAuth(SETTINGS.PAYPAL_CLIENT_ID, SETTINGS.PAYPAL_CLIENT_SECRET.get_secret_value()),
                data={"grant_type": "client_credentials"}
            )
            auth_data = await auth_response.json()
            access_token = auth_data["access_token"]

            # 捕获支付
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {access_token}"
            }
            capture_response = await session.post(capture_url, headers=headers)
            capture_details = await capture_response.json()

            # 检查支付是否成功
            if capture_response.status == 201 and capture_details.get("status") == "COMPLETED":
                return {
                    "status": "SUCCESS",
                    "details": capture_details
                }
            else:
                logger.error(f"支付捕获失败: {capture_details}")
                return {
                    "status": "FAILED",
                    "error": capture_details.get("message", "未知错误"),
                    "details": capture_details
                }
        except Exception as e:
            logger.error(f"捕获支付时发生异常: {str(e)}")
            return {
                "status": "ERROR",
                "error": str(e),
                "details": None
            }

async def check_paypal_order_status(order_id: str) -> Dict:
    """检查PayPal订单状态"""

    auth_url = f"{SETTINGS.PAYPAL_API_URL}/v1/oauth2/token"
    order_url = f"{SETTINGS.PAYPAL_API_URL}/v2/checkout/orders/{order_id}"

    async with aiohttp.ClientSession() as session:
        try:
            # 获取访问令牌
            auth_response = await session.post(
                auth_url,
                auth=aiohttp.BasicAuth(SETTINGS.PAYPAL_CLIENT_ID, SETTINGS.PAYPAL_CLIENT_SECRET.get_secret_value()),
                data={"grant_type": "client_credentials"}
            )
            auth_data = await auth_response.json()
            access_token = auth_data["access_token"]

            # 获取订单状态
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {access_token}"
            }
            order_response = await session.get(order_url, headers=headers)
            order_details = await order_response.json()
            logger.info("check_paypal_order_status::order_details %s", order_details)

            # 检查订单状态
            if order_response.status == 200:
                return {
                    "status": "SUCCESS",
                    "order_status": order_details.get("status"),
                    "details": order_details
                }
            else:
                logger.error(f"获取订单状态失败: {order_details}")
                return {
                    "status": "FAILED",
                    "error": order_details.get("message", "未知错误"),
                    "details": order_details
                }
        except Exception as e:
            logger.error(f"检查订单状态时发生异常: {str(e)}")
            return {
                "status": "ERROR",
                "error": str(e),
                "details": None
            }
